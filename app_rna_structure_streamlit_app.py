# -*- coding: utf-8 -*-
"""3Dsecondary_Structure19_updated.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gb1eGt46FlrvwKkmdYdMIYYMhdRbmWgc
"""

# ðŸ§¬ INTEGRATED RNA STRUCTURE TOOL IN COLAB

# Step 1: Install Required Libraries
import subprocess
import sys

# Install required packages at runtime
required_packages = [
    "biopython", "py3Dmol", "viennarna", "scikit-learn", "matplotlib"
]

for package in required_packages:
    subprocess.run([sys.executable, "-m", "pip", "install", package, "--quiet"])

# Step 2: Import Libraries
import os
import py3Dmol
import numpy as np
import matplotlib.pyplot as plt
from Bio import SeqIO
from google.colab import files
import RNA
from sklearn.metrics import confusion_matrix, roc_curve, auc, accuracy_score, precision_score, recall_score, f1_score

# Step 3: Upload Two FASTA Files
print("Upload RNA Sequence 1 (FASTA format)")
uploaded1 = files.upload()
file1 = list(uploaded1.keys())[0]
seq1 = str(SeqIO.read(file1, "fasta").seq).replace("T", "U")

print("Upload RNA Sequence 2 (FASTA format)")
uploaded2 = files.upload()
file2 = list(uploaded2.keys())[0]
seq2 = str(SeqIO.read(file2, "fasta").seq).replace("T", "U")

# Step 4: Predict Secondary Structures with ViennaRNA (RNAfold)
def predict_structure(seq):
    structure, mfe = RNA.fold(seq)
    return structure, mfe

dot1, mfe1 = predict_structure(seq1)
dot2, mfe2 = predict_structure(seq2)

print(f"Structure 1 (MFE={mfe1}):\n{dot1}")
print(f"Structure 2 (MFE={mfe2}):\n{dot2}")

# Step 5: Save and Download Structures
def save_structure(seq, structure, name):
    filename = f"{name}_structure.txt"
    with open(filename, "w") as f:
        f.write(f">{name}\n{seq}\n{structure}\n")
    files.download(filename)

save_structure(seq1, dot1, "RNA1")
save_structure(seq2, dot2, "RNA2")

# Step 6: Simulate Training & Validation (Mock LSTM Loss)
epochs = 40
train_loss = np.exp(-0.1 * np.arange(epochs)) + 0.05 * np.random.rand(epochs)
val_loss = np.exp(-0.1 * np.arange(epochs)) + 0.06 * np.random.rand(epochs)

plt.figure()
plt.plot(train_loss, label="Training Loss")
plt.plot(val_loss, label="Validation Loss")
plt.title("LSTM Model Training vs Validation")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.grid(True)
plt.savefig("loss_plot.png")
files.download("loss_plot.png")
plt.show()

# Step 7: Evaluation Metrics (Simulated)
y_true = np.random.randint(0, 2, 100)
y_pred = np.random.randint(0, 2, 100)

print("\nConfusion Matrix:")
print(confusion_matrix(y_true, y_pred))
print("Accuracy:", accuracy_score(y_true, y_pred))
print("Precision:", precision_score(y_true, y_pred))
print("Recall:", recall_score(y_true, y_pred))
print("F1 Score:", f1_score(y_true, y_pred))

# ROC Curve
fpr, tpr, _ = roc_curve(y_true, y_pred)
roc_auc = auc(fpr, tpr)
plt.figure()
plt.plot(fpr, tpr, label=f"ROC curve (area = {roc_auc:.2f})")
plt.plot([0, 1], [0, 1], "k--")
plt.title("ROC Curve")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.legend(loc="lower right")
plt.grid(True)
plt.savefig("roc_curve.png")
files.download("roc_curve.png")
plt.show()

# Step 8: Visualize Sample 3D Structure using py3Dmol
# Note: Replace below sample PDB if you have real PDB files
pdb_id = "1EHZ"  # Sample RNA PDB for visualization
viewer = py3Dmol.view(query=f'pdb:{pdb_id}', width=400, height=400)
viewer.setStyle({'cartoon': {'color': 'spectrum'}})
viewer.setBackgroundColor('white')
viewer.zoomTo()
viewer.show()



# ðŸ§¬ INTEGRATED RNA STRUCTURE TOOL IN COLAB

# Step 1: Install Required Libraries
!pip install -q biopython py3Dmol viennarna scikit-learn matplotlib

# Step 2: Import Libraries
import os
import py3Dmol
import numpy as np
import matplotlib.pyplot as plt
from Bio import SeqIO
from google.colab import files
import RNA
from sklearn.metrics import confusion_matrix, roc_curve, auc, accuracy_score, precision_score, recall_score, f1_score

# Step 3: Upload Two FASTA Files
print("Upload RNA Sequence 1 (FASTA format)")
uploaded1 = files.upload()
file1 = list(uploaded1.keys())[0]
seq1 = str(SeqIO.read(file1, "fasta").seq).replace("T", "U")

print("Upload RNA Sequence 2 (FASTA format)")
uploaded2 = files.upload()
file2 = list(uploaded2.keys())[0]
seq2 = str(SeqIO.read(file2, "fasta").seq).replace("T", "U")

# Step 4: Predict Secondary Structures with ViennaRNA (RNAfold)
def predict_structure(seq):
    structure, mfe = RNA.fold(seq)
    return structure, mfe

dot1, mfe1 = predict_structure(seq1)
dot2, mfe2 = predict_structure(seq2)

print(f"Structure 1 (MFE={mfe1}):\n{dot1}")
print(f"Structure 2 (MFE={mfe2}):\n{dot2}")

# Step 5: Save and Download Structures
def save_structure(seq, structure, name):
    filename = f"{name}_structure.txt"
    with open(filename, "w") as f:
        f.write(f">{name}\n{seq}\n{structure}\n")
    files.download(filename)

save_structure(seq1, dot1, "RNA1")
save_structure(seq2, dot2, "RNA2")

# Step 6: Simulate Training & Validation (Mock LSTM Loss)
epochs = 40
train_loss = np.exp(-0.1 * np.arange(epochs)) + 0.05 * np.random.rand(epochs)
val_loss = np.exp(-0.1 * np.arange(epochs)) + 0.06 * np.random.rand(epochs)

plt.figure()
plt.plot(train_loss, label="Training Loss")
plt.plot(val_loss, label="Validation Loss")
plt.title("LSTM Model Training vs Validation")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.grid(True)
plt.savefig("loss_plot.png")
files.download("loss_plot.png")
plt.show()

# Step 7: Evaluation Metrics (Simulated)
y_true = np.random.randint(0, 2, 100)
y_pred = np.random.randint(0, 2, 100)

print("\nConfusion Matrix:")
print(confusion_matrix(y_true, y_pred))
print("Accuracy:", accuracy_score(y_true, y_pred))
print("Precision:", precision_score(y_true, y_pred))
print("Recall:", recall_score(y_true, y_pred))
print("F1 Score:", f1_score(y_true, y_pred))

# ROC Curve
fpr, tpr, _ = roc_curve(y_true, y_pred)
roc_auc = auc(fpr, tpr)
plt.figure()
plt.plot(fpr, tpr, label=f"ROC curve (area = {roc_auc:.2f})")
plt.plot([0, 1], [0, 1], "k--")
plt.title("ROC Curve")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.legend(loc="lower right")
plt.grid(True)
plt.savefig("roc_curve.png")
files.download("roc_curve.png")
plt.show()

# Step 8: Visualize Sample 3D Structure using py3Dmol
# Note: Replace below sample PDB if you have real PDB files
pdb_id = "1EHZ"  # Sample RNA PDB for visualization
viewer = py3Dmol.view(query=f'pdb:{pdb_id}', width=400, height=400)
viewer.setStyle({'cartoon': {'color': 'spectrum'}})
viewer.setBackgroundColor('white')
viewer.zoomTo()
viewer.show()

# ðŸ§¬ INTEGRATED RNA STRUCTURE TOOL - Colab Version

# STEP 1: Install Libraries
!pip install -q biopython py3Dmol viennarna scikit-learn seaborn matplotlib

# STEP 2: Import Required Libraries
import os
import py3Dmol
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from Bio import SeqIO
from google.colab import files
import RNA
from sklearn.metrics import confusion_matrix, roc_curve, auc, accuracy_score, precision_score, recall_score, f1_score

# STEP 3: Upload Two FASTA Files
print("Upload RNA Sequence 1 (FASTA)")
uploaded1 = files.upload()
file1 = list(uploaded1.keys())[0]
seq1 = str(SeqIO.read(file1, "fasta").seq).replace("T", "U")

print("Upload RNA Sequence 2 (FASTA)")
uploaded2 = files.upload()
file2 = list(uploaded2.keys())[0]
seq2 = str(SeqIO.read(file2, "fasta").seq).replace("T", "U")

# STEP 4: RNAfold Structure Prediction
def predict_structure(seq):
    structure, mfe = RNA.fold(seq)
    return structure, mfe

dot1, mfe1 = predict_structure(seq1)
dot2, mfe2 = predict_structure(seq2)

print(f"\nRNA 1 Structure (MFE={mfe1:.2f}):\n{dot1}")
print(f"\nRNA 2 Structure (MFE={mfe2:.2f}):\n{dot2}")

# STEP 5: Save Dot-Bracket Structures
def save_structure(seq, structure, name):
    fname = f"{name}_dotbracket.txt"
    with open(fname, "w") as f:
        f.write(f">{name}\n{seq}\n{structure}\n")
    files.download(fname)

save_structure(seq1, dot1, "RNA1")
save_structure(seq2, dot2, "RNA2")

# STEP 6: Simulated LSTM Loss Training/Validation
epochs = 40
train_loss = np.exp(-0.1 * np.arange(epochs)) + 0.05 * np.random.rand(epochs)
val_loss = np.exp(-0.1 * np.arange(epochs)) + 0.06 * np.random.rand(epochs)

plt.figure()
plt.plot(train_loss, label="Training Loss")
plt.plot(val_loss, label="Validation Loss")
plt.title("LSTM Training vs Validation Loss")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig("loss_plot.png")
files.download("loss_plot.png")
plt.show()

# STEP 7: Evaluation - Metrics
y_true = np.random.randint(0, 2, 100)
y_pred = np.random.randint(0, 2, 100)

print("Evaluation Metrics:")
print("Accuracy:", accuracy_score(y_true, y_pred))
print("Precision:", precision_score(y_true, y_pred))
print("Recall:", recall_score(y_true, y_pred))
print("F1 Score:", f1_score(y_true, y_pred))

# STEP 8: Confusion Matrix (Text + Plot)
cm = confusion_matrix(y_true, y_pred)
labels = ['Negative', 'Positive']
print("\nConfusion Matrix:")
print(cm)

plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=labels, yticklabels=labels)
plt.title("Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.tight_layout()
plt.savefig("confusion_matrix.png")
files.download("confusion_matrix.png")
plt.show()

# STEP 9: ROC Curve
fpr, tpr, _ = roc_curve(y_true, y_pred)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, label=f"ROC curve (AUC = {roc_auc:.2f})")
plt.plot([0, 1], [0, 1], "k--")
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig("roc_curve.png")
files.download("roc_curve.png")
plt.show()

# STEP 10: 3D Visualization using py3Dmol (PDB Sample)
print("Showing example 3D RNA structure (1EHZ)")
viewer = py3Dmol.view(query='pdb:1EHZ', width=400, height=400)
viewer.setStyle({'cartoon': {'color': 'spectrum'}})
viewer.setBackgroundColor('white')
viewer.zoomTo()
viewer.show()

# Write the integrated .ipynb content again using a correct file path for Google Colab
notebook_code = '''
{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# ðŸ§¬ Integrated RNA 3D Structure Prediction and Visualization Tool\\n",
    "For Common Carp P4a Gene (FASTA Input) | LSTM + ViennaRNA + RNAComposer + py3Dmol"
   ]
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "!pip install -q biopython py3Dmol viennarna scikit-learn matplotlib seaborn tensorflow"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "from google.colab import files\\n",
    "from Bio import SeqIO\\n",
    "import RNA\\n",
    "print('Upload Common Carp P4a Gene FASTA file')\\n",
    "uploaded = files.upload()\\n",
    "filename = list(uploaded.keys())[0]\\n",
    "record = SeqIO.read(filename, 'fasta')\\n",
    "sequence = str(record.seq).replace('T', 'U')\\n",
    "fc = RNA.fold_compound(sequence)\\n",
    "structure, mfe = fc.mfe()\\n",
    "print('Predicted dot-bracket structure:', structure)\\n",
    "with open('structure.dbn', 'w') as f:\\n",
    "    f.write(f'>{record.id}\\n{sequence}\\n{structure}')\\n",
    "files.download('structure.dbn')"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Simulated LSTM model for RNA structure prediction (replace with real bpRNA data for real training)\\n",
    "import numpy as np\\n",
    "from sklearn.model_selection import train_test_split\\n",
    "from sklearn.metrics import classification_report, confusion_matrix, roc_curve\\n",
    "import seaborn as sns\\n",
    "import matplotlib.pyplot as plt\\n",
    "import tensorflow as tf\\n",
    "from tensorflow.keras.models import Sequential\\n",
    "from tensorflow.keras.layers import LSTM, Dense\\n",
    "\\n",
    "X = np.random.rand(1000, 50)\\n",
    "y = np.random.randint(0, 2, 1000)\\n",
    "X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2)\\n",
    "model = Sequential([\\n",
    "    LSTM(64, input_shape=(50,1)),\\n",
    "    Dense(1, activation='sigmoid')\\n",
    "])\\n",
    "model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])\\n",
    "history = model.fit(X_train[...,None], y_train, epochs=5, validation_data=(X_val[...,None], y_val))"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Plot training vs validation accuracy/loss\\n",
    "plt.figure(figsize=(12,5))\\n",
    "plt.subplot(1,2,1)\\n",
    "plt.plot(history.history['accuracy'], label='Train Acc')\\n",
    "plt.plot(history.history['val_accuracy'], label='Val Acc')\\n",
    "plt.legend(); plt.title('Accuracy')\\n",
    "plt.subplot(1,2,2)\\n",
    "plt.plot(history.history['loss'], label='Train Loss')\\n",
    "plt.plot(history.history['val_loss'], label='Val Loss')\\n",
    "plt.legend(); plt.title('Loss')\\n",
    "plt.show()"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Confusion Matrix and ROC\\n",
    "y_pred = model.predict(X_val[...,None]) > 0.5\\n",
    "print(classification_report(y_val, y_pred))\\n",
    "sns.heatmap(confusion_matrix(y_val, y_pred), annot=True, fmt='d')\\n",
    "plt.title('Confusion Matrix')\\n",
    "plt.show()\\n",
    "fpr, tpr, _ = roc_curve(y_val, y_pred)\\n",
    "plt.plot(fpr, tpr); plt.title('ROC Curve')\\n",
    "plt.xlabel('FPR'); plt.ylabel('TPR')\\n",
    "plt.grid(True); plt.show()"
   ],
   "execution_count": null,
   "outputs": []
  },
  {
   "cell_type": "code",
   "metadata": {},
   "source": [
    "# Upload PDB file and view in 3D\\n",
    "uploaded_pdb = files.upload()\\n",
    "pdb_file = list(uploaded_pdb.keys())[0]\\n",
    "import py3Dmol\\n",
    "with open(pdb_file) as f:\\n",
    "    pdb = f.read()\\n",
    "view = py3Dmol.view(width=500, height=400)\\n",
    "view.addModel(pdb, 'pdb')\\n",
    "view.setStyle({ 'cartoon': { 'color': 'spectrum' } })\\n",
    "view.zoomTo()\\n",
    "view.show()"
   ],
   "execution_count": null,
   "outputs": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "name": "python3",
   "display_name": "Python 3"
  },
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
'''

# Save to current directory in Colab
file_path = "Integrated_RNA_3D_Tool.ipynb"
with open(file_path, "w") as f:
    f.write(notebook_code)

# Make downloadable
from google.colab import files
files.download(file_path)



import py3Dmol
from IPython.display import Image

# Example: Load a small RNA PDB structure (replace with your actual structure)
pdb_data = '''
HEADER    RNA
ATOM      1  P     A A   1      11.546  13.207   5.123  1.00 40.00           P
ATOM      2  O5'   A A   1      10.274  13.885   5.237  1.00 40.00           O
... (add your real PDB data here) ...
END
'''

view = py3Dmol.view(width=400, height=400)
view.addModel(pdb_data, "pdb")
view.setStyle({'cartoon': {'color': 'spectrum'}})
view.zoomTo()
view.show()

# Optionally save screenshot (requires additional tools in local Jupyter, not in Colab)

!pip install tensorflow biopython matplotlib scikit-learn

import os
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_curve, auc, confusion_matrix, ConfusionMatrixDisplay
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.optimizers import Adam
from Bio import SeqIO
from google.colab import files

# ----- Utility Functions -----
def one_hot_encode(seq):
    mapping = {'A': [1, 0, 0, 0],
               'U': [0, 1, 0, 0],
               'G': [0, 0, 1, 0],
               'C': [0, 0, 0, 1]}
    return np.array([mapping.get(base.upper(), [0, 0, 0, 0]) for base in seq])

def load_fasta_and_encode(uploaded_files, seq_len=100):
    X = []
    y = []
    for file in uploaded_files:
        for record in SeqIO.parse(file, "fasta"):
            seq = str(record.seq)[:seq_len]
            encoded = one_hot_encode(seq)
            padded = np.pad(encoded, ((0, seq_len - len(encoded)), (0, 0)), mode='constant')
            X.append(padded)
            labels = np.random.randint(0, 2, len(seq))  # dummy labels: 0=unpaired, 1=paired
            labels = np.pad(labels, (0, seq_len - len(labels)), mode='constant')
            y.append(labels)
    return np.array(X), np.array(y)

# ----- File Upload Step -----
print("Upload two FASTA files (each with RNA sequences)...")
uploaded = files.upload()
uploaded_files = list(uploaded.keys())

if len(uploaded_files) != 2:
    raise ValueError("Please upload exactly two FASTA files.")

X, y = load_fasta_and_encode(uploaded_files, seq_len=100)
y_cat = to_categorical(y, num_classes=2)

# ----- Train-Test Split -----
X_train, X_val, y_train, y_val = train_test_split(X, y_cat, test_size=0.2, random_state=42)

# ----- Model Building -----
model = Sequential([
    LSTM(64, return_sequences=True, input_shape=(X.shape[1], X.shape[2])),
    Dense(2, activation='softmax')
])
model.compile(optimizer=Adam(learning_rate=0.001), loss='categorical_crossentropy', metrics=['accuracy'])

# ----- Model Training -----
history = model.fit(X_train, y_train, validation_data=(X_val, y_val), epochs=10, batch_size=8)

# ----- Plot Loss and Accuracy -----
plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.title('Loss Curve')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.savefig("loss_curve.png")
files.download("loss_curve.png")

plt.subplot(1, 2, 2)
plt.plot(history.history['accuracy'], label='Train Acc')
plt.plot(history.history['val_accuracy'], label='Val Acc')
plt.title('Accuracy Curve')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()
plt.savefig("accuracy_curve.png")
files.download("accuracy_curve.png")

# ----- ROC Curve -----
y_val_pred = model.predict(X_val)
fpr, tpr, _ = roc_curve(y_val[:, :, 1].ravel(), y_val_pred[:, :, 1].ravel())
roc_auc = auc(fpr, tpr)
plt.figure()
plt.plot(fpr, tpr, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], 'k--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend(loc="lower right")
plt.savefig("roc_curve.png")
files.download("roc_curve.png")

# ----- Confusion Matrix -----
y_val_flat = np.argmax(y_val, axis=-1).ravel()
y_pred_flat = np.argmax(y_val_pred, axis=-1).ravel()
cm = confusion_matrix(y_val_flat, y_pred_flat)
disp = ConfusionMatrixDisplay(confusion_matrix=cm)
disp.plot()
plt.title("Confusion Matrix")
plt.savefig("confusion_matrix.png")
files.download("confusion_matrix.png")

# ----- Dummy 3D Structure Prediction Output -----
with open("rna_3d_structure.pdb", "w") as f:
    f.write("HEADER    DUMMY RNA 3D STRUCTURE\n")
    f.write("ATOM      1  P   A A   1      11.000  12.000  13.000  1.00 20.00           P\n")
    f.write("END\n")
files.download("rna_3d_structure.pdb")
print("Downloadable RNA 3D PDB structure generated (dummy example).")

# Model & output files saved and downloadable
print("âœ… All outputs generated successfully.")
